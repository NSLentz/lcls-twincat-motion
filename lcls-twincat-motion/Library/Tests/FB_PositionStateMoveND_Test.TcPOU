<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_PositionStateMoveND_Test" Id="{b9c8729d-ba0e-45a6-b763-53e484d22a2a}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PositionStateMoveND_Test EXTENDS FB_MotorTestSuite
(*
    Test that FB_PositionStateMoveND can be used to move motors to named state positions
    And that the API behaves exactly as described.
*)
VAR
    astMotionStage: ARRAY[1..MotionConstants.MAX_STATE_MOTORS] OF ST_MotionStage;
    afbMotionStage: ARRAY[1..3] OF FB_MotionStage;
    astGoalPositions: ARRAY[1..MotionConstants.MAX_STATE_MOTORS] OF ST_PositionState;
    afbInternal: ARRAY[1..3] OF FB_PositionStateInternal;
    stDummyPos: ST_PositionState;
    fbMove: FB_PositionStateMoveND;

    bInit: BOOL;
    nTestCounter: UINT;
    bOneTestDone: BOOL;
    fTestStartPos: LREAL;
    tonTimer: TON;
    nIter: DINT;
    bStatesReady: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
IF NOT bInit THEN
    ResetGoals();
    bInit := TRUE;
END_IF

bStatesReady := TRUE;
FOR nIter := 1 TO 3 DO
    afbInternal[nIter](
        stMotionStage:=astMotionStage[nIter],
        stPositionState:=astGoalPositions[nIter],
    );
    bStatesReady := bStatesReady AND astGoalPositions[nIter].bUpdated;
    SetEnables(astMotionStage[nIter]);
    afbMotionStage[nIter](stMotionStage:=astMotionStage[nIter]);
END_FOR

IF bStatesReady AND nTestCounter = 0 THEN
    // Don't run any tests until the states are ready
    nTestCounter := 1;
    // Warm up the motion FB with a exec false runthrough
    fbMove(
        astMotionStage := astMotionStage,
        astPositionState := astGoalPositions,
        nActiveMotorCount := 3,
        bExecute := FALSE,
    );
END_IF

// Move to somewhere
TestMove(1, 1, 5, 10, FALSE);
// Somewhere else
TestMove(2, -10, 0, 5, FALSE);
// Interrupt on the way to the last place
TestMove(3, 0, 0, 0, TRUE);

// Move to somewhere in a sequenced manner (motor 2, then motor 3, then motor 1).
TestMoveSequence(
	nTestIndex := 4, 
	fMotor1Pos := 1,  iMotor1SequenceOrder := 3,
	fMotor2Pos := 5,  iMotor2SequenceOrder := 1,
	fMotor3Pos := 10, iMotor3SequenceOrder := 2, 
	bInterrupt := FALSE);
// Move to somewhere else in a different sequence (motors 1 and 2 at the same time, motor 3 after)
TestMoveSequence(
	nTestIndex := 5, 
	fMotor1Pos := -10, iMotor1SequenceOrder := 2,
	fMotor2Pos := -5,  iMotor2SequenceOrder := 1,
	fMotor3Pos := 1,   iMotor3SequenceOrder := 3, 
	bInterrupt := FALSE);
// Move to somewhere else in a different sequence (motor 1, then 2, then 3)
TestMoveSequence(
	nTestIndex := 6, 
	fMotor1Pos := 1,  iMotor1SequenceOrder := 1,
	fMotor2Pos := 5,  iMotor2SequenceOrder := 2,
	fMotor3Pos := 10, iMotor3SequenceOrder := 3, 
	bInterrupt := FALSE);
// Move to somewhere else in a different sequence (motor 3, then 2, then 1)
TestMoveSequence(
	nTestIndex := 7, 
	fMotor1Pos := -10, iMotor1SequenceOrder := 3,
	fMotor2Pos := 2,   iMotor2SequenceOrder := 2,
	fMotor3Pos := 4,   iMotor3SequenceOrder := 1, 
	bInterrupt := FALSE);
// Interrupt on the way to the last place. Make sure all sequence moves are interrupted.
TestMoveSequence(//nTestIndex:=8, 0, 2, 0, 3, 0, 1, TRUE);
	nTestIndex := 8, 
	fMotor1Pos := 0, iMotor1SequenceOrder := 2,
	fMotor2Pos := 0, iMotor2SequenceOrder := 3,
	fMotor3Pos := 0, iMotor3SequenceOrder := 1, 
	bInterrupt := TRUE);

IF bOneTestDone THEN
    bOneTestDone := FALSE;
    nTestCounter := nTestCounter + 1;
    ResetGoals();
    fbMove(
        astMotionStage := astMotionStage,
        astPositionState := astGoalPositions,
        nActiveMotorCount := 3,
        bExecute := FALSE,
        bReset := TRUE,
    );
    tonTimer(IN:=FALSE);
END_IF
// Use this timer to time out any tests that stall
tonTimer(
    IN:=bStatesReady,
    PT:=T#5s,
);]]></ST>
    </Implementation>
    <Method Name="ResetGoals" Id="{596670bf-1f3d-4561-9f5d-f06c122e58e6}">
      <Declaration><![CDATA[METHOD ResetGoals
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
astGoalPositions[1].sName := 'Goal1';
astGoalPositions[1].fPosition := 0;
astGoalPositions[1].fDelta := 1;
astGoalPositions[1].fVelocity := 10;
astGoalPositions[1].bUseRawCounts := FALSE;
astGoalPositions[1].bSequenceMoves := FALSE;
SetGoodState(astGoalPositions[1]);

astGoalPositions[2].sName := 'Goal2';
astGoalPositions[2].fPosition := 0;
astGoalPositions[2].fDelta := 1;
astGoalPositions[2].fVelocity := 10;
astGoalPositions[2].bUseRawCounts := FALSE;
astGoalPositions[2].bSequenceMoves := FALSE;
SetGoodState(astGoalPositions[2]);

astGoalPositions[3].sName := 'Goal3';
astGoalPositions[3].fPosition := 0;
astGoalPositions[3].fDelta := 1;
astGoalPositions[3].fVelocity := 10;
astGoalPositions[3].bUseRawCounts := FALSE;
astGoalPositions[3].bSequenceMoves := FALSE;
SetGoodState(astGoalPositions[3]);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="TestMove" Id="{3180ed3d-87cb-4e20-beff-2be7f8597c71}">
      <Declaration><![CDATA[METHOD TestMove
VAR_INPUT
    nTestIndex: UINT;
    fMotor1Pos: LREAL;
    fMotor2Pos: LREAL;
    fMotor3Pos: LREAL;
    bInterrupt: BOOL;
END_VAR
VAR_INST
    bLocalInit: BOOL;
    bInterruptStarted: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(CONCAT('TestMove', UINT_TO_STRING(nTestIndex)));
IF nTestCounter <> nTestIndex THEN
    RETURN;
END_IF

IF NOT bLocalInit THEN
    // Starting output checks
    AssertFalse(
        Condition:=fbMove.bBusy,
        Message:='Tried to start test with busy motor',
    );
    AssertFalse(
        Condition:=fbMove.bError,
        Message:='Tried to start test with errored motor',
    );
    bLocalInit := TRUE;
END_IF

astGoalPositions[1].fPosition := fMotor1Pos;
astGoalPositions[2].fPosition := fMotor2Pos;
astGoalPositions[3].fPosition := fMotor3Pos;

bInterruptStarted S= bInterrupt AND astMotionStage[1].bBusy AND astMotionStage[2].bBusy AND astMotionStage[3].bBusy;
fbMove(
    astMotionStage:=astMotionStage,
    astPositionState:=astGoalPositions,
    nActiveMotorCount:=3,
    bExecute:=NOT bInterruptStarted,
);
IF fbMove.bDone OR tonTimer.Q OR (bInterruptStarted AND NOT fbMove.bBusy) THEN
    IF bInterrupt THEN
        AssertFalse(
            fbMove.bAtState,
            Message:='Should have been interrupted, but made it to the goal',
        );
    ELSE
        AssertTrue(
            fbMove.bAtState,
            Message:='Did not end at the state',
        );
        FOR nIter := 1 TO 3 DO
            AssertEquals_LREAL(
                Expected:=astGoalPositions[nIter].fPosition,
                Actual:=astMotionStage[nIter].stAxisStatus.fActPosition,
                Delta:=0.01,
                Message:='Did not reach the goal state',
            );
        END_FOR

    END_IF
    AssertFalse(
        fbMove.bBusy,
        Message:='Was busy while done',
    );
    AssertFalse(
        fbMove.bError,
        Message:='Should not end in error',
    );

    bOneTestDone := TRUE;
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="TestMoveSequence" Id="{05aeaa03-a150-4bf4-b5c8-1ee451d84845}">
      <Declaration><![CDATA[METHOD TestMoveSequence
VAR_INPUT
    nTestIndex: UINT;
    fMotor1Pos: LREAL;
	iMotor1SequenceOrder: UINT;
    fMotor2Pos: LREAL;
	iMotor2SequenceOrder: UINT;
    fMotor3Pos: LREAL;
	iMotor3SequenceOrder: UINT;
    bInterrupt: BOOL;
END_VAR
VAR_INST
    bLocalInit: BOOL;
    bInterruptStarted: BOOL;
	bMotor1MovedOutOfSequence: BOOL;
	bMotor1NotDoneMoving: BOOL;
	bMotor1BeforeMotor2: BOOL;
	bMotor1BeforeMotor3: BOOL;
	bMotor2MovedOutOfSequence: BOOL;
	bMotor2NotDoneMoving: BOOL;
	bMotor2BeforeMotor1: BOOL;
	bMotor2BeforeMotor3: BOOL;
	bMotor3MovedOutOfSequence: BOOL;
	bMotor3NotDoneMoving: BOOL;
	bMotor3BeforeMotor2: BOOL;
	bMotor3BeforeMotor1: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(CONCAT('TestMoveSequence', UINT_TO_STRING(nTestIndex)));
IF nTestCounter <> nTestIndex THEN
    RETURN;
END_IF

IF NOT bLocalInit THEN
    // Starting output checks
    AssertFalse(
        Condition:=fbMove.bBusy,
        Message:='Tried to start test with busy motor',
    );
    AssertFalse(
        Condition:=fbMove.bError,
        Message:='Tried to start test with errored motor',
    );
    bLocalInit := TRUE;
	
	ADSLOGSTR(
        msgCtrlMask := ADSLOG_MSGTYPE_HINT, 
        msgFmtStr   := 'Test run %s', 
        strArg      := CONCAT('TestMoveSequence', UINT_TO_STRING(nTestIndex))
    ); 
END_IF

astGoalPositions[1].fPosition := fMotor1Pos;
astGoalPositions[1].bSequenceMoves := TRUE;
astGoalPositions[1].iSequenceOrder := iMotor1SequenceOrder;
astGoalPositions[2].fPosition := fMotor2Pos;
astGoalPositions[2].bSequenceMoves := TRUE;
astGoalPositions[2].iSequenceOrder := iMotor2SequenceOrder;
astGoalPositions[3].fPosition := fMotor3Pos;
astGoalPositions[3].bSequenceMoves := TRUE;
astGoalPositions[3].iSequenceOrder := iMotor3SequenceOrder;

bInterruptStarted S= bInterrupt AND astMotionStage[1].bBusy AND astMotionStage[2].bBusy AND astMotionStage[3].bBusy;
fbMove(
    astMotionStage:=astMotionStage,
    astPositionState:=astGoalPositions,
    nActiveMotorCount:=3,
    bExecute:=NOT bInterruptStarted,
);

bMotor1BeforeMotor2 := astGoalPositions[1].iSequenceOrder < astGoalPositions[2].iSequenceOrder;
bMotor1BeforeMotor3 := astGoalPositions[1].iSequenceOrder < astGoalPositions[3].iSequenceOrder;
bMotor2BeforeMotor3 := astGoalPositions[2].iSequenceOrder < astGoalPositions[3].iSequenceOrder;
bMotor2BeforeMotor1 := NOT bMotor1BeforeMotor2;
bMotor3BeforeMotor2 := NOT bMotor2BeforeMotor3;
bMotor3BeforeMotor1 := NOT bMotor3BeforeMotor1;

bMotor1NotDoneMoving := NOT astMotionStage[1].bDone;// OR abs(astMotionStage[1].stAxisStatus.fActVelocity) > astMotionStage[1].fVelocity / 10.0;
bMotor2NotDoneMoving := NOT astMotionStage[2].bDone;// OR abs(astMotionStage[2].stAxisStatus.fActVelocity) > astMotionStage[2].fVelocity / 10.0;
bMotor3NotDoneMoving := NOT astMotionStage[3].bDone;// OR abs(astMotionStage[3].stAxisStatus.fActVelocity) > astMotionStage[3].fVelocity / 10.0;

bMotor1MovedOutOfSequence := astMotionStage[1].bBusy AND ((bMotor2BeforeMotor1 AND bMotor2NotDoneMoving) OR (bMotor3BeforeMotor1 AND bMotor3NotDoneMoving));
bMotor2MovedOutOfSequence := astMotionStage[2].bBusy AND ((bMotor1BeforeMotor2 AND bMotor1NotDoneMoving) OR (bMotor3BeforeMotor2 AND bMotor3NotDoneMoving));
bMotor3MovedOutOfSequence := astMotionStage[3].bBusy AND ((bMotor2BeforeMotor3 AND bMotor2NotDoneMoving) OR (bMotor1BeforeMotor3 AND bMotor1NotDoneMoving));

AssertFalse(
	bMotor1MovedOutOfSequence,
	Message:='Motor 1 moved out of the defined sequence',
);
AssertFalse(
	bMotor2MovedOutOfSequence,
	Message:='Motor 2 moved out of the defined sequence',
);
AssertFalse(
	bMotor3MovedOutOfSequence,
	Message:='Motor 3 moved out of the defined sequence',
);

IF fbMove.bDone OR tonTimer.Q OR (bInterruptStarted AND NOT fbMove.bBusy) THEN
    IF bInterrupt THEN
        AssertFalse(
            fbMove.bAtState,
            Message:='Should have been interrupted, but made it to the goal',
        );
    ELSE
        AssertTrue(
            fbMove.bAtState,
            Message:='Did not end at the state',
        );
        FOR nIter := 1 TO 3 DO
            AssertEquals_LREAL(
                Expected:=astGoalPositions[nIter].fPosition,
                Actual:=astMotionStage[nIter].stAxisStatus.fActPosition,
                Delta:=0.01,
                Message:='Did not reach the goal state',
            );
        END_FOR

    END_IF
    AssertFalse(
        fbMove.bBusy,
        Message:='Was busy while done',
    );
    AssertFalse(
        fbMove.bError,
        Message:='Should not end in error',
    );

    bOneTestDone := TRUE;
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_PositionStateMoveND_Test">
      <LineId Id="3" Count="33" />
      <LineId Id="77" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="78" Count="1" />
      <LineId Id="92" Count="1" />
      <LineId Id="96" Count="2" />
      <LineId Id="80" Count="0" />
      <LineId Id="104" Count="4" />
      <LineId Id="84" Count="1" />
      <LineId Id="99" Count="4" />
      <LineId Id="86" Count="1" />
      <LineId Id="109" Count="4" />
      <LineId Id="90" Count="1" />
      <LineId Id="114" Count="4" />
      <LineId Id="37" Count="18" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PositionStateMoveND_Test.ResetGoals">
      <LineId Id="3" Count="5" />
      <LineId Id="27" Count="0" />
      <LineId Id="9" Count="6" />
      <LineId Id="28" Count="0" />
      <LineId Id="16" Count="6" />
      <LineId Id="29" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PositionStateMoveND_Test.TestMove">
      <LineId Id="3" Count="60" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PositionStateMoveND_Test.TestMoveSequence">
      <LineId Id="3" Count="15" />
      <LineId Id="151" Count="0" />
      <LineId Id="153" Count="3" />
      <LineId Id="152" Count="0" />
      <LineId Id="19" Count="2" />
      <LineId Id="86" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="24" Count="7" />
      <LineId Id="115" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="128" Count="3" />
      <LineId Id="127" Count="0" />
      <LineId Id="136" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="137" Count="1" />
      <LineId Id="102" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="140" Count="1" />
      <LineId Id="96" Count="2" />
      <LineId Id="142" Count="8" />
      <LineId Id="99" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="32" Count="31" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>