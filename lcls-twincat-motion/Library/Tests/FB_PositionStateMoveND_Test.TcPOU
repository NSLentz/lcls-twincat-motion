<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_PositionStateMoveND_Test" Id="{b9c8729d-ba0e-45a6-b763-53e484d22a2a}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PositionStateMoveND_Test EXTENDS FB_MotorTestSuite
(*
    Test that FB_PositionStateMoveND can be used to move motors to named state positions
    And that the API behaves exactly as described.
*)
VAR
    astMotionStage: ARRAY[1..MotionConstants.MAX_STATE_MOTORS] OF ST_MotionStage;
    afbMotionStage: ARRAY[1..3] OF FB_MotionStage;
    astGoalPositions: ARRAY[1..MotionConstants.MAX_STATE_MOTORS] OF ST_PositionState;
    afbInternal: ARRAY[1..3] OF FB_PositionStateInternal;
    stDummyPos: ST_PositionState;
    fbMove: FB_PositionStateMoveND;

    bInit: BOOL;
    nTestCounter: UINT;
    bOneTestDone: BOOL;
    fTestStartPos: LREAL;
    tonTimer: TON;
    nIter: DINT;
    bStatesReady: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
IF NOT bInit THEN
    ResetGoals();
    bInit := TRUE;
END_IF

bStatesReady := TRUE;
FOR nIter := 1 TO 3 DO
    afbInternal[nIter](
        stMotionStage:=astMotionStage[nIter],
        stPositionState:=astGoalPositions[nIter],
    );
    bStatesReady := bStatesReady AND astGoalPositions[nIter].bUpdated;
    SetEnables(astMotionStage[nIter]);
    afbMotionStage[nIter](stMotionStage:=astMotionStage[nIter]);
END_FOR

IF bStatesReady AND nTestCounter = 0 THEN
    // Don't run any tests until the states are ready
    nTestCounter := 1;
    // Warm up the motion FB with a exec false runthrough
    fbMove(
        astMotionStage := astMotionStage,
        astPositionState := astGoalPositions,
        nActiveMotorCount := 3,
        bExecute := FALSE,
    );
END_IF

// Move to somewhere
TestMove(1, 1, 5, 10, FALSE);
// Somewhere else
TestMove(2, -10, 0, 5, FALSE);


// Move to somewhere in a sequenced manner (motor 2, then motor 3, then motor 1).
TestMoveSequence(
    nTestIndex := 3,
    fMotor1Pos := 20,  iMotor1SequenceOrder := 3,
    fMotor2Pos := -20,  iMotor2SequenceOrder := 1,
    fMotor3Pos := 20, iMotor3SequenceOrder := 2,
    bInterrupt := FALSE);
(*
// Move to somewhere else in a different sequence (motors 1 and 2 at the same time, motor 3 after)
TestMoveSequence(
    nTestIndex := 4,
    fMotor1Pos := -10, iMotor1SequenceOrder := 2,
    fMotor2Pos := -5,  iMotor2SequenceOrder := 1,
    fMotor3Pos := 1,   iMotor3SequenceOrder := 3,
    bInterrupt := FALSE);
// Move to somewhere else in a different sequence (motor 1, then 2, then 3)
TestMoveSequence(
    nTestIndex := 5,
    fMotor1Pos := 1,  iMotor1SequenceOrder := 1,
    fMotor2Pos := 5,  iMotor2SequenceOrder := 2,
    fMotor3Pos := 10, iMotor3SequenceOrder := 3,
    bInterrupt := FALSE);
// Move to somewhere else in a different sequence (motor 3, then 2, then 1)
TestMoveSequence(
    nTestIndex := 6,
    fMotor1Pos := -10, iMotor1SequenceOrder := 3,
    fMotor2Pos := 2,   iMotor2SequenceOrder := 2,
    fMotor3Pos := 4,   iMotor3SequenceOrder := 1,
    bInterrupt := FALSE);
// Interrupt on the way to the last place. Make sure all sequence moves are interrupted.
TestMoveSequence(
    nTestIndex := 7,
    fMotor1Pos := 0, iMotor1SequenceOrder := 2,
    fMotor2Pos := 0, iMotor2SequenceOrder := 3,
    fMotor3Pos := 0, iMotor3SequenceOrder := 1,
    bInterrupt := TRUE);*)

// Interrupt on the way to the last place
TestMove(4, 0, 0, 0, TRUE);

IF bOneTestDone THEN
    bOneTestDone := FALSE;
    nTestCounter := nTestCounter + 1;
    ResetGoals();
    fbMove(
        astMotionStage := astMotionStage,
        astPositionState := astGoalPositions,
        nActiveMotorCount := 3,
        bExecute := FALSE,
        bReset := TRUE,
    );
    tonTimer(IN:=FALSE);
END_IF
// Use this timer to time out any tests that stall
tonTimer(
    IN:=bStatesReady,
    PT:=T#5s,
);]]></ST>
    </Implementation>
    <Method Name="ResetGoals" Id="{596670bf-1f3d-4561-9f5d-f06c122e58e6}">
      <Declaration><![CDATA[METHOD ResetGoals
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
astGoalPositions[1].sName := 'Goal1';
astGoalPositions[1].fPosition := 0;
astGoalPositions[1].fDelta := 1;
astGoalPositions[1].fVelocity := 10;
astGoalPositions[1].bUseRawCounts := FALSE;
astGoalPositions[1].bSequenceMoves := FALSE;
SetGoodState(astGoalPositions[1]);

astGoalPositions[2].sName := 'Goal2';
astGoalPositions[2].fPosition := 0;
astGoalPositions[2].fDelta := 1;
astGoalPositions[2].fVelocity := 10;
astGoalPositions[2].bUseRawCounts := FALSE;
astGoalPositions[2].bSequenceMoves := FALSE;
SetGoodState(astGoalPositions[2]);

astGoalPositions[3].sName := 'Goal3';
astGoalPositions[3].fPosition := 0;
astGoalPositions[3].fDelta := 1;
astGoalPositions[3].fVelocity := 10;
astGoalPositions[3].bUseRawCounts := FALSE;
astGoalPositions[3].bSequenceMoves := FALSE;
SetGoodState(astGoalPositions[3]);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="TestMove" Id="{3180ed3d-87cb-4e20-beff-2be7f8597c71}">
      <Declaration><![CDATA[METHOD TestMove
VAR_INPUT
    nTestIndex: UINT;
    fMotor1Pos: LREAL;
    fMotor2Pos: LREAL;
    fMotor3Pos: LREAL;
    bInterrupt: BOOL;
END_VAR
VAR_INST
    bLocalInit: BOOL;
    bInterruptStarted: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(CONCAT('TestMove', UINT_TO_STRING(nTestIndex)));
IF nTestCounter <> nTestIndex THEN
    RETURN;
END_IF

IF NOT bLocalInit THEN
    // Starting output checks
    AssertFalse(
        Condition:=fbMove.bBusy,
        Message:='Tried to start test with busy motor',
    );
    AssertFalse(
        Condition:=fbMove.bError,
        Message:='Tried to start test with errored motor',
    );
    bLocalInit := TRUE;
END_IF

astGoalPositions[1].fPosition := fMotor1Pos;
astGoalPositions[2].fPosition := fMotor2Pos;
astGoalPositions[3].fPosition := fMotor3Pos;

bInterruptStarted S= bInterrupt AND astMotionStage[1].bBusy AND astMotionStage[2].bBusy AND astMotionStage[3].bBusy;
fbMove(
    astMotionStage:=astMotionStage,
    astPositionState:=astGoalPositions,
    nActiveMotorCount:=3,
    bExecute:=NOT bInterruptStarted,
);
IF fbMove.bDone OR tonTimer.Q OR (bInterruptStarted AND NOT fbMove.bBusy) THEN
    IF bInterrupt THEN
        AssertFalse(
            fbMove.bAtState,
            Message:='Should have been interrupted, but made it to the goal',
        );
    ELSE
        AssertTrue(
            fbMove.bAtState,
            Message:='Did not end at the state',
        );
        FOR nIter := 1 TO 3 DO
            AssertEquals_LREAL(
                Expected:=astGoalPositions[nIter].fPosition,
                Actual:=astMotionStage[nIter].stAxisStatus.fActPosition,
                Delta:=0.01,
                Message:='Did not reach the goal state',
            );
        END_FOR

    END_IF
    AssertFalse(
        fbMove.bBusy,
        Message:='Was busy while done',
    );
    AssertFalse(
        fbMove.bError,
        Message:='Should not end in error',
    );

    bOneTestDone := TRUE;
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="TestMoveSequence" Id="{05aeaa03-a150-4bf4-b5c8-1ee451d84845}">
      <Declaration><![CDATA[METHOD TestMoveSequence
VAR_INPUT
    nTestIndex: UINT;
    fMotor1Pos: LREAL;
    iMotor1SequenceOrder: UINT;
    fMotor2Pos: LREAL;
    iMotor2SequenceOrder: UINT;
    fMotor3Pos: LREAL;
    iMotor3SequenceOrder: UINT;
    bInterrupt: BOOL;
END_VAR
VAR_INST
    bLocalInit: BOOL;
    bInterruptStarted: BOOL;
    fMotor1StartPos: REAL;
    bMotor1Moved: BOOL;
    bMotor1MovedOutOfSequence: BOOL;
    bMotor1NotDoneMoving: BOOL;
    bMotor1BeforeMotor2: BOOL;
    bMotor1BeforeMotor3: BOOL;
    fMotor2StartPos: REAL;
    bMotor2Moved: BOOL;
    bMotor2MovedOutOfSequence: BOOL;
    bMotor2NotDoneMoving: BOOL;
    bMotor2BeforeMotor1: BOOL;
    bMotor2BeforeMotor3: BOOL;
    fMotor3StartPos: REAL;
    bMotor3Moved: BOOL;
    bMotor3MovedOutOfSequence: BOOL;
    bMotor3NotDoneMoving: BOOL;
    bMotor3BeforeMotor2: BOOL;
    bMotor3BeforeMotor1: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(CONCAT('TestMoveSequence', UINT_TO_STRING(nTestIndex)));
IF nTestCounter <> nTestIndex THEN
    RETURN;
END_IF

IF NOT bLocalInit THEN
    // Starting output checks
    AssertFalse(
        Condition:=fbMove.bBusy,
        Message:='Tried to start test with busy motor',
    );
    AssertFalse(
        Condition:=fbMove.bError,
        Message:='Tried to start test with errored motor',
    );

    fMotor1StartPos := astMotionStage[1].stAxisStatus.fActPosition;
    fMotor2StartPos := astMotionStage[2].stAxisStatus.fActPosition;
    fMotor3StartPos := astMotionStage[3].stAxisStatus.fActPosition;

    bLocalInit := TRUE;
END_IF

astGoalPositions[1].fPosition := fMotor1Pos;
astGoalPositions[1].bSequenceMoves := TRUE;
astGoalPositions[1].iSequenceOrder := iMotor1SequenceOrder;
astGoalPositions[2].fPosition := fMotor2Pos;
astGoalPositions[2].bSequenceMoves := TRUE;
astGoalPositions[2].iSequenceOrder := iMotor2SequenceOrder;
astGoalPositions[3].fPosition := fMotor3Pos;
astGoalPositions[3].bSequenceMoves := TRUE;
astGoalPositions[3].iSequenceOrder := iMotor3SequenceOrder;

//bInterruptStarted S= bInterrupt AND astMotionStage[1].bBusy AND astMotionStage[2].bBusy AND astMotionStage[3].bBusy;
fbMove(
    astMotionStage:=astMotionStage,
    astPositionState:=astGoalPositions,
    nActiveMotorCount:=3,
    bExecute:=TRUE //NOT bInterruptStarted,
);

bMotor1BeforeMotor2 := astGoalPositions[1].iSequenceOrder < astGoalPositions[2].iSequenceOrder;
bMotor1BeforeMotor3 := astGoalPositions[1].iSequenceOrder < astGoalPositions[3].iSequenceOrder;
bMotor2BeforeMotor3 := astGoalPositions[2].iSequenceOrder < astGoalPositions[3].iSequenceOrder;
bMotor2BeforeMotor1 := NOT bMotor1BeforeMotor2;
bMotor3BeforeMotor2 := NOT bMotor2BeforeMotor3;
bMotor3BeforeMotor1 := NOT bMotor3BeforeMotor1;

bMotor1NotDoneMoving := NOT astMotionStage[1].bDone;// OR abs(astMotionStage[1].stAxisStatus.fActVelocity) > astMotionStage[1].fVelocity / 10.0;
bMotor2NotDoneMoving := NOT astMotionStage[2].bDone;// OR abs(astMotionStage[2].stAxisStatus.fActVelocity) > astMotionStage[2].fVelocity / 10.0;
bMotor3NotDoneMoving := NOT astMotionStage[3].bDone;// OR abs(astMotionStage[3].stAxisStatus.fActVelocity) > astMotionStage[3].fVelocity / 10.0;

bMotor1Moved := ABS(fMotor1StartPos - astMotionStage[1].stAxisStatus.fActPosition) > 0.01;
bMotor2Moved := ABS(fMotor2StartPos - astMotionStage[2].stAxisStatus.fActPosition) > 0.01;
bMotor3Moved := ABS(fMotor3StartPos - astMotionStage[3].stAxisStatus.fActPosition) > 0.01;

bMotor1MovedOutOfSequence := bMotor1Moved AND ((bMotor2BeforeMotor1 AND bMotor2NotDoneMoving) OR (bMotor3BeforeMotor1 AND bMotor3NotDoneMoving));
bMotor2MovedOutOfSequence := bMotor2Moved AND ((bMotor1BeforeMotor2 AND bMotor1NotDoneMoving) OR (bMotor3BeforeMotor2 AND bMotor3NotDoneMoving));
bMotor3MovedOutOfSequence := bMotor3Moved AND ((bMotor2BeforeMotor3 AND bMotor2NotDoneMoving) OR (bMotor1BeforeMotor3 AND bMotor1NotDoneMoving));

(*
AssertFalse(
    bMotor1MovedOutOfSequence,
    Message:='Motor 1 moved out of the defined sequence',
);
AssertFalse(
    bMotor2MovedOutOfSequence,
    Message:='Motor 2 moved out of the defined sequence',
);
AssertFalse(
    bMotor3MovedOutOfSequence,
    Message:='Motor 3 moved out of the defined sequence',
);
*)

IF fbMove.bDone OR tonTimer.Q OR (bInterruptStarted AND NOT fbMove.bBusy) THEN
    IF bInterrupt THEN
        AssertFalse(
            fbMove.bAtState,
            Message:='Should have been interrupted, but made it to the goal',
        );
    ELSE
        AssertTrue(
            fbMove.bAtState,
            Message:='Did not end at the state',
        );
        FOR nIter := 1 TO 3 DO
            AssertEquals_LREAL(
                Expected:=astGoalPositions[nIter].fPosition,
                Actual:=astMotionStage[nIter].stAxisStatus.fActPosition,
                Delta:=0.01,
                Message:='Did not reach the goal state',
            );
        END_FOR

    END_IF
    AssertFalse(
        fbMove.bBusy,
        Message:='Was busy while done',
    );
    AssertFalse(
        fbMove.bError,
        Message:='Should not end in error',
    );

    bOneTestDone := TRUE;
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>